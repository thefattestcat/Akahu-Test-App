'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var axios = require('axios');
var uuid = require('uuid');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);

/**
 * Build a URL from constituent components.
 */
function buildUrl({ protocol, host, port, path = '', query = {} }) {
    // If not specified, port will be chosen by browser based on protocol choice (http or https).
    const _port = port ? `:${port}` : '';
    // Clean `undefined` values from the query params 
    const cleanedQuery = Object.fromEntries(Object.entries(query || {}).filter(([_, v]) => typeof v !== 'undefined'));
    // Convert to URL encoded query string
    const queryString = Object.keys(cleanedQuery).length !== 0
        ? '?' + new URLSearchParams(cleanedQuery).toString()
        : '';
    return `${protocol}://${host}${_port}/${path}${queryString}`;
}
function pick(obj, ...props) {
    return Object.fromEntries(Object.entries(obj).filter(([k]) => props.includes(k)));
}
/**
 * Axios error interceptor to retry on network failures.
 * Dormant by default - is activated by including `retries` in the axios config.
 */
function axiosRetryOnNetworkError(error) {
    // Only handle axios errors.
    if (!error.isAxiosError)
        return Promise.reject(error);
    const { config } = error;
    const { method, headers, retries = 0, __retryCount = 0 } = config;
    // POST requests can only be retried if they include an idempotency key.
    // Other methods (i.e. get, patch, delete) are considered idempotent by default.
    const isIdempotent = method.toUpperCase() !== 'POST' ||
        typeof headers['Idempotency-Key'] === 'string';
    const shouldRetry = isIdempotent &&
        __retryCount < retries &&
        isNetworkError(error) && // Don't retry due to server errors
        isRetryAllowed(error); // Don't retry if the error is permanent (e.g. SSL related)
    if (!shouldRetry) {
        return Promise.reject(error);
    }
    config.__retryCount = __retryCount + 1;
    return axios__default['default'](config);
}
/**
 * Determine whether an axios error instance was caused by network error
 * (and should therefore be retryable).
 *
 * Borrowed from {@link https://github.com/softonic/axios-retry/blob/master/es/index.js}
 * with minor changes as we want to retry on timeout.
 */
function isNetworkError(error) {
    return error.isAxiosError &&
        !error.response && // Network errors have no response
        !axios__default['default'].isCancel(error); // Don't retry cancelled requests
}
/**
 * Inspect network error code from axios to determine if it makes sense to retry it.
 *
 * Borrowed from {@link https://github.com/sindresorhus/is-retry-allowed/blob/main/index.js}
 */
function isRetryAllowed(error) {
    return error.code === undefined || // Errors due to timeout have no error code.
        !retryDenyList.has(error.code);
}
const retryDenyList = new Set([
    'ENOTFOUND',
    'ENETUNREACH',
    'UNABLE_TO_GET_ISSUER_CERT',
    'UNABLE_TO_GET_CRL',
    'UNABLE_TO_DECRYPT_CERT_SIGNATURE',
    'UNABLE_TO_DECRYPT_CRL_SIGNATURE',
    'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY',
    'CERT_SIGNATURE_FAILURE',
    'CRL_SIGNATURE_FAILURE',
    'CERT_NOT_YET_VALID',
    'CERT_HAS_EXPIRED',
    'CRL_NOT_YET_VALID',
    'CRL_HAS_EXPIRED',
    'ERROR_IN_CERT_NOT_BEFORE_FIELD',
    'ERROR_IN_CERT_NOT_AFTER_FIELD',
    'ERROR_IN_CRL_LAST_UPDATE_FIELD',
    'ERROR_IN_CRL_NEXT_UPDATE_FIELD',
    'OUT_OF_MEM',
    'DEPTH_ZERO_SELF_SIGNED_CERT',
    'SELF_SIGNED_CERT_IN_CHAIN',
    'UNABLE_TO_GET_ISSUER_CERT_LOCALLY',
    'UNABLE_TO_VERIFY_LEAF_SIGNATURE',
    'CERT_CHAIN_TOO_LONG',
    'CERT_REVOKED',
    'INVALID_CA',
    'PATH_LENGTH_EXCEEDED',
    'INVALID_PURPOSE',
    'CERT_UNTRUSTED',
    'CERT_REJECTED',
    'HOSTNAME_MISMATCH'
]);
// https://github.com/flexdinesh/browser-or-node/blob/master/src/index.js
const isBrowser = () => (typeof window !== 'undefined' && typeof window.document !== 'undefined');
const isNode = () => {
    var _a;
    return (typeof process === 'object' &&
        Boolean((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node) &&
        !isReactNative());
};
// https://github.com/facebook/react-native/commit/3c65e62183ce05893be0822da217cb803b121c61
const isReactNative = () => (typeof navigator === 'object' && navigator.product === 'ReactNative');

const version = "1.1.0";

class AkahuError extends Error {
}
/**
 * Flag that can be used to detect exceptions thrown by the Akahu SDK.
 */
AkahuError.isAkahuError = true;
/**
 * Error type for error responses received from the Akahu API.
 * An error response is characterised by a non 2XX status code and/or a body
 * payload that contains `success: false` along with an accompanying error message.
 *
 * @noInheritDoc
 * @category Error
 */
class AkahuErrorResponse extends AkahuError {
    /** @internal */
    constructor(response) {
        const { status, statusText, data = {} } = response;
        const { message, error, error_description } = data;
        let _message;
        // `error` and `error_description` are specific to the OAuth endpoints.
        // `error_description` is more user-friendly, but optional:
        // https://www.oauth.com/oauth2-servers/server-side-apps/possible-errors/
        if (typeof error_description === 'string') {
            _message = error_description;
        }
        else if (error in AkahuErrorResponse.oAuthErrorCodeMap) {
            _message = AkahuErrorResponse.oAuthErrorCodeMap[error];
        }
        else {
            // Detail for other error responses are nested under the `message` key.
            // Include a fallback to statusText just in case things go really wrong.
            _message = message !== null && message !== void 0 ? message : statusText;
        }
        super(_message);
        this.status = status;
        this.response = response;
    }
}
/** @internal */
AkahuErrorResponse.oAuthErrorCodeMap = {
    invalid_request: 'Invalid OAuth request.',
    unauthorized_client: 'This application is not authorized to make this request.',
    unsupported_response_type: 'Unsupported OAuth response type.',
    invalid_scope: 'Unknown or invalid scope.',
    server_error: 'Unknown server error.',
    temporarily_unavailable: 'The authorization server is temporarily unavailable.',
    invalid_grant: 'Invalid OAuth request.',
};
/**
 * Error type for errors that occur during the webhook validation process.
 *
 * @noInheritDoc
 * @category Error
 */
class AkahuWebhookValidationError extends AkahuError {
}

/**
 * @internal
 */
class BaseResource {
    /**
     * @internal
     */
    constructor(client) {
        this._client = client;
    }
}

/**
 * Utilities for authorizing users using OAuth2.
 *
 * {@link https://developers.akahu.nz/docs/authorizing-with-oauth2}
 *
 * @category Resource
 */
class AuthResource extends BaseResource {
    /**
     * Build the OAuth Authorization URL
     *
     * @param options Options for customising the generated URL.
     *
     * {@link https://developers.akahu.nz/docs/authorizing-with-oauth2#the-authorization-request}
    */
    buildAuthorizationUrl(options) {
        // Unpack options with defaults
        const { protocol, host, port, path, response_type, scope, redirect_uri, state, email, connection } = {
            protocol: 'https',
            host: 'oauth.akahu.io',
            path: '',
            response_type: 'code',
            scope: 'ENDURING_CONSENT',
            ...options
        };
        // Construct main OAuth query params
        const { appToken: client_id } = this._client.authConfig;
        const query = { response_type, redirect_uri, scope, client_id };
        // Include optional params if specified in options
        if (email)
            query.email = email;
        if (connection)
            query.connection = connection;
        if (state)
            query.state = state;
        return buildUrl({ protocol, host, port, path, query });
    }
    /**
     * Exchange an OAuth authorization code for an access token.
     *
     * {@link https://developers.akahu.nz/docs/authorizing-with-oauth2#exchanging-the-authorization-code}
     * {@link https://developers.akahu.nz/reference/post_token}
     */
    async exchange(code, redirect_uri, grant_type = 'authorization_code') {
        // POST parameters for OAuth code exchange
        const { appToken: client_id, appSecret: client_secret } = this._client.authConfig;
        const data = { code, redirect_uri, grant_type, client_id, client_secret };
        return await this._client._apiCall({ path: '/token', method: 'POST', data });
    }
    /**
     * Revoke the specified user auth token:
     *
     * {@link https://developers.akahu.nz/reference/delete_token}
     */
    async revoke(token) {
        return await this._client._apiCall({ path: '/token', method: 'DELETE', auth: { token } });
    }
}

/**
 * Utilities for requesting identity verification using OAuth2.
 *
 * {@link https://developers.akahu.nz/docs/identity-verification}
 *
 * @category Resource
 */
class IdentitiesResource extends BaseResource {
    /**
     * Build the Identity OAuth Authorization URL.
     *
     * {@link https://developers.akahu.nz/docs/identity-verification#the-authorization-request}
    */
    buildAuthorizationUrl(params) {
        // Borrow implementation from `OAuthResource.buildAuthorizationUrl`
        return this._client.auth.buildAuthorizationUrl({ scope: 'ONEOFF', ...params });
    }
    /**
     * Retrieve an identity result using the code/id returned after successful authorization using the
     * OAuth identity verification flow.
     *
     * {@link https://developers.akahu.nz/docs/identity-verification#retrieving-identity-results-with-the-oauth-result-code}
     */
    async get(code) {
        return await this._client._apiCall({ path: `/identity/${code}`, auth: { basic: true } });
    }
}

/**
 * Utilities for managing Akahu accounts that have been linked by users.
 *
 * {@link https://developers.akahu.nz/docs/accessing-account-data}
 *
 * @category Resource
 */
class AccountsResource extends BaseResource {
    /**
     * List all accounts that have been connected by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_accounts}
     */
    async list(token) {
        return await this._client._apiCall({
            path: "/accounts",
            auth: { token },
        });
    }
    /**
     * Get a single account that has been connected by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_accounts-id}
     */
    async get(token, accountId) {
        return await this._client._apiCall({
            path: `/accounts/${accountId}`,
            auth: { token },
        });
    }
    /**
     * List transactions for a specified account.
     *
     * {@link https://developers.akahu.nz/reference/get_accounts-id-transactions}
     */
    async listTransactions(token, accountId, query = {}) {
        return await this._client._apiCall({
            path: `/accounts/${accountId}/transactions`,
            auth: { token },
            query,
        });
    }
    /**
     * List pending transactions for a specified account.
     *
     * {@link https://developers.akahu.nz/reference/get_accounts-id-transactions-pending}
     */
    async listPendingTransactions(token, accountId) {
        return await this._client._apiCall({
            path: `/accounts/${accountId}/transactions/pending`,
            auth: { token },
        });
    }
    /**
     * Refresh a single account that has been connected by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/post_refresh-id}
     */
    async refresh(token, accountId) {
        return await this._client._apiCall({
            path: `/refresh/${accountId}`,
            method: "POST",
            auth: { token },
        });
    }
    /**
     * Refresh all accounts that have been connected by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/post_refresh}
     */
    async refreshAll(token) {
        return await this._client._apiCall({
            path: "/refresh",
            method: "POST",
            auth: { token },
        });
    }
}

/**
 * Utilities to view connections that are available to your app, and refresh
 * accounts under a given connection.
 *
 * @category Resource
 */
class ConnectionsResource extends BaseResource {
    /**
     * List all connections that the app has access to.
     *
     * {@link https://developers.akahu.nz/reference/get_connections}
     */
    async list() {
        return await this._client._apiCall({ path: '/connections', auth: { basic: true } });
    }
    /**
     * Get an individual connection detail.
     *
     * {@link https://developers.akahu.nz/reference/get_connections-id}
     */
    async get(connectionId) {
        return await this._client._apiCall({
            path: `/connections/${connectionId}`,
            auth: { basic: true }
        });
    }
    /**
     * Refresh all accounts that are made using the given connection and have been
     * connected by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/post_refresh-id}
     */
    async refresh(token, connectionId) {
        return await this._client._apiCall({
            path: `/refresh/${connectionId}`,
            auth: { token }
        });
    }
}

/**
 * Utilities for managing bank account payments on behalf of users.
 *
 * {@link https://developers.akahu.nz/docs/making-a-payment}
 *
 * @category Resource
 */
class PaymentsResource extends BaseResource {
    /**
     * Get a single payment made by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_payments-id}
     */
    async get(token, paymentId) {
        return await this._client._apiCall({
            path: `/payments/${paymentId}`,
            auth: { token }
        });
    }
    /**
     * List all payments made in the provided date range by the user associated
     * with the specified `token`. Defaults to the last 30 days if no date range
     * is provided.
     *
     * {@link https://developers.akahu.nz/reference/get_payments}
     */
    async list(token, query = {}) {
        // List endpoint with optional query params for date range
        return await this._client._apiCall({
            path: '/payments',
            auth: { token },
            query
        });
    }
    /**
     * Initiate a payment to an external bank account on behalf of the user associated
     * with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/post_payments}
     */
    async create(token, payment) {
        return await this._client._apiCall({
            path: '/payments',
            method: 'POST',
            auth: { token },
            data: payment
        });
    }
}

/**
 * Utilities for managing bank account transfers on behalf of users.
 *
 * {@link https://developers.akahu.nz/docs/making-a-transfer}
 *
 * @category Resource
 */
class TransfersResource extends BaseResource {
    /**
     * Get a single transfer made by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_transfers-id}
     */
    async get(token, transferId) {
        return await this._client._apiCall({
            path: `/transfers/${transferId}`,
            auth: { token }
        });
    }
    /**
     * List all transfers made in the provided date range by the user associated
     * with the specified `token`. Defaults to the last 30 days if no date range
     * is provided.
     *
     * {@link https://developers.akahu.nz/reference/get_transfers}
     */
    async list(token, query = {}) {
        // List endpoint with optional query params for date range
        return await this._client._apiCall({
            path: '/transfers',
            auth: { token },
            query
        });
    }
    /**
     * Initiate a transfer between two of the users bank accounts.
     *
     * {@link https://developers.akahu.nz/reference/post_transfers}
     */
    async create(token, transfer) {
        return await this._client._apiCall({
            path: '/transfers',
            method: 'POST',
            auth: { token },
            data: transfer
        });
    }
}

/**
 * Utilities for retrieving bank transactions from connected user accounts.
 *
 * {@link https://developers.akahu.nz/docs/accessing-transactional-data}
 *
 * @category Resource
 */
class TransactionsResource extends BaseResource {
    /**
     * List all transactions for all accounts that have been connected by the user associated with the
     * specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_transactions}
     */
    async list(token, query = {}) {
        // Paginated list endpoint with optional query params for date range & cursor
        return await this._client._apiCall({
            path: "/transactions",
            auth: { token },
            query,
        });
    }
    /**
     * List all pending transactions for all accounts that have been connected by the user associated with the
     * specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_transactions-pending}
     */
    async listPending(token) {
        // Non-paginated list endpoint of pending transactions
        return await this._client._apiCall({
            path: "/transactions/pending",
            auth: { token },
        });
    }
    /**
     * Get a single transaction from an account that has been connected by the user associated with
     * the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_transactions-id}
     */
    async get(token, transactionId) {
        return await this._client._apiCall({
            path: `/transactions/${transactionId}`,
            auth: { token },
        });
    }
    /**
     * Get multiple transactions by id.
     *
     * All transactions must belong to the user associated with the specified `token`.
     *
     * This method may be useful to bulk refresh changed transaction data
     * in response to a webhook event.
     *
     * {@link https://developers.akahu.nz/reference/post_transactions-ids}
     */
    async getMany(token, transactionIds) {
        // Non-paginated list endpoint subset by transaction id
        return this._client._apiCall({
            path: "/transactions/ids",
            method: "POST",
            auth: { token },
            data: transactionIds,
        });
    }
}

/**
 * Utilities for retrieving information about the Akahu user.
 *
 * @category Resource
 */
class UsersResource extends BaseResource {
    /**
     * Get the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_me}
     */
    async get(token) {
        return await this._client._apiCall({ path: '/me', auth: { token } });
    }
}

// crypto may not be available on all platforms (e.g React Native).
// This is ok as we only need it server side. We just need to handle the import conditionally.
let crypto;
try {
    crypto = require('crypto');
}
catch (e) { }
/**
 * Default in-memory cache for caching the webhook signing key.
 */
class DefaultKeyCache {
    constructor() {
        this._cache = {};
    }
    async get(key) {
        var _a;
        return (_a = this._cache[key]) !== null && _a !== void 0 ? _a : null;
    }
    async set(key, value) {
        this._cache[key] = value;
    }
}
/**
 * Utilities for managing, retrieving, and validating webhooks.
 *
 * {@link https://developers.akahu.nz/docs/reference-webhooks}
 *
 * @category Resource
 */
class WebhooksResource extends BaseResource {
    constructor() {
        super(...arguments);
        this.defaultKeyCache = new DefaultKeyCache();
    }
    /**
     * Gets active webhooks for the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_webhooks}
     */
    async list(token) {
        return await this._client._apiCall({
            path: '/webhooks',
            auth: { token }
        });
    }
    /**
     * Subscribe to a webhook.
     *
     * @returns The newly created webhook id.
     *
     * {@link https://developers.akahu.nz/reference/post_webhooks}
     */
    async subscribe(token, webhook) {
        return await this._client._apiCall({
            path: '/webhooks',
            method: 'POST',
            auth: { token },
            data: webhook
        });
    }
    /**
     * Unsubscribe from a previously created webhook.
     *
     * {@link https://developers.akahu.nz/reference/delete_webhooks-id}
     */
    async unsubscribe(token, webhookId) {
        return await this._client._apiCall({
            path: `/webhooks/${webhookId}`,
            method: 'DELETE',
            auth: { token },
        });
    }
    /**
     * List all webhook events with the specified status in the specified date
     * range (defaults to last 30 days).
     *
     * {@link https://developers.akahu.nz/reference/get_webhook-events}
     */
    async listEvents(query) {
        return await this._client._apiCall({
            path: '/webhook-events',
            auth: { basic: true },
            query,
        });
    }
    /**
     * Get a webhook signing public-key by id.
     *
     * {@link https://developers.akahu.nz/reference/get_keys-id}
     */
    async getPublicKey(keyId) {
        return await this._client._apiCall({
            path: `/keys/${keyId}`,
            auth: { basic: true },
        });
    }
    /**
     * Helper to validate a webhook request payload.
     *
     * See the project README for example usage.
     *
     * @returns The deserialized webhook payload after successful validation
     *
     * @throws {@link AkahuWebhookValidationError}
     * if validation of the webhook fails due to invalid signature or expired signing key.
     *
     * @throws {@link AkahuErrorResponse}
     * if the client fails to fetch the specified signing key from the Akahu API.
     *
     * {@link https://developers.akahu.nz/docs/reference-webhooks}
     */
    async validateWebhook(keyId, signature, webhookRequestBody, cacheConfig = {}) {
        // Coerce keyId as a number
        const _keyId = Number(keyId);
        // Validate that keyId is an integer. Includes null check because Number(null) === 0 
        if (!Number.isInteger(_keyId) || keyId === null) {
            throw new AkahuWebhookValidationError(`Can't validate webhook request. keyId must be an integer (received ${keyId}).`);
        }
        // Initialize cache config with defaults
        const _cacheConfig = {
            cache: this.defaultKeyCache,
            key: 'akahu__webhook_key',
            maxAgeMs: 24 * 60 * 60 * 1000,
            ...cacheConfig
        };
        // Get the public key matching keyId - either from cache or API lookup
        const publicKey = await this._getPublicKey(_keyId, _cacheConfig);
        // Validate the webhook signature using the retreived public key
        const isValid = this._validateWebhookSignature(publicKey, signature, webhookRequestBody);
        if (!isValid) {
            throw new AkahuWebhookValidationError('Webhook signature verificaton failed.');
        }
        return JSON.parse(webhookRequestBody);
    }
    /**
     * Get the public key (by id) to validate a webhook signature.
     * The key will be retrieved from cache if possible, falling back to API lookup.
     * If a cached key exists with a newer id, an error will be thrown, as the existence of a newer
     * key implies that the key has been rotated and the requested key is no longer valid.
     *
     * {@link https://developers.akahu.nz/docs/reference-webhooks#caching}
     */
    async _getPublicKey(keyId, cacheConfig) {
        // Attempt to lookup key from cache
        const keyDataFromCache = await this._getPublicKeyFromCache(cacheConfig);
        // Validate the cached key matches
        if (keyDataFromCache !== null) {
            const { id, key } = keyDataFromCache;
            // Validate that the cached key has same id as requested key
            if (keyId === id) {
                return key;
            }
            // Throw an error if the requested key has been superseded
            if (keyId < id) {
                throw new AkahuWebhookValidationError(`Webhook signing key (id: ${keyId}) has expired. Unable to validate webhook.`);
            }
            // Fallback to lookup via API
        }
        // Lookup key data from API
        const freshKeyData = {
            id: keyId,
            lastRefreshed: new Date().toISOString(),
            key: await this.getPublicKey(keyId),
        };
        // Cache the updated key data
        await this._cacheKeyData(freshKeyData, cacheConfig);
        return freshKeyData.key;
    }
    /**
     * Lookup current active public key from the cache.
     * If the key has been in the cache for more than `maxAgeMs` milliseconds, it is considered
     * stale, and will be ignored - causing it to be re-fetched from Akahu. `maxAgeMs` defaults to 24 hours.
     *
     * {@link https://developers.akahu.nz/docs/reference-webhooks#caching}
     */
    async _getPublicKeyFromCache(cacheConfig) {
        const { cache, key: cacheKey, maxAgeMs } = cacheConfig;
        // Lookup key data from cache
        const rawFromCache = await cache.get(cacheKey);
        // Cache hit
        if (typeof rawFromCache === 'string') {
            let keyData;
            // Deserialize key data JSON from cache
            try {
                keyData = JSON.parse(rawFromCache);
            }
            catch (e) {
                // Warn but no error if invalid JSON in cache data
                console.warn(`akahu-sdk: Failed to deserialize webhook key data from cache (key: ${cacheKey}).`);
            }
            // Validate the key data from cache
            if (typeof keyData !== 'undefined') {
                // Ensure that the cache is at most `maxAgeMs` old
                const cacheAgeMs = Date.now() - Date.parse(keyData.lastRefreshed);
                // NaN check in case lastRefreshed is invalid date string or undefined somehow
                if (!Number.isNaN(cacheAgeMs) && cacheAgeMs < maxAgeMs) {
                    return keyData;
                }
            }
        }
        // Cache miss or invalid cache data
        return null;
    }
    /**
     * Add the public key that has been fetched from the API to the cache.
     *
     * {@link https://developers.akahu.nz/docs/reference-webhooks#caching}
     */
    async _cacheKeyData(keyData, cacheConfig) {
        const { cache, key } = cacheConfig;
        await cache.set(key, JSON.stringify(keyData));
    }
    /**
     * Validate a webhook and associated signature using the public key fetched from the Akahu API.
     *
     * {@link https://developers.akahu.nz/docs/reference-webhooks#verification}
     */
    _validateWebhookSignature(publicKey, signature, webhookBody) {
        if (typeof crypto === 'undefined') {
            throw new Error('Webhook validation is only supported on Node.js environments.');
        }
        const verify = crypto.createVerify("sha256");
        verify.update(webhookBody);
        verify.end();
        return verify.verify(publicKey, signature, "base64");
    }
}

// We will set this header to report SDK version
const X_AKAHU_SDK = `akahu-sdk-js/${version}`;
// We allow custom axios configuration using this subset of options
const allowedAxiosOptions = ['headers', 'timeout', 'proxy', 'retries'];
/**
 * The AkahuClient provides a simple interface to the Akahu API and utilities
 * that assist with common usage patterns.
 *
 * AkahuClient uses {@link https://axios-http.com/docs/intro axios} under the hood to make
 * API requests. A subset of axios request options can be passed through to the underlying axios
 * instance using the options available in {@link AkahuClientConfig}.
 *
 * In the case of an error while making an API request, you can expect to handle one of the
 * following two exceptions:
 *
 * - {@link AkahuErrorResponse} When an error response is returned from the API
 * - {@link https://github.com/axios/axios/blob/v0.21.1/index.d.ts#L85 AxiosError} when an error
 *    occurred during the request process, but no response was received (i.e. due to network issues).
 *
 * @category API client
 */
class AkahuClient {
    constructor(config) {
        const { appToken, appSecret, apiVersion, protocol, host, port, ...axiosOptions } = {
            apiVersion: 'v1',
            protocol: 'https',
            host: 'api.akahu.io',
            ...config
        };
        // Sanity check to warn against insecure App Secret usage
        if (typeof appSecret !== 'undefined' && !isNode()) {
            console.warn('Warning: do not use the appSecret option with AkahuClient in a client-side ' +
                'application. This option is only intended to be used on a server environment.');
        }
        this.authConfig = { appToken, appSecret };
        // Common headers that we will send with each request
        const akahuHeaders = {
            'X-Akahu-Sdk': X_AKAHU_SDK,
            'X-Akahu-Id': appToken, // Identify the calling app
        };
        // Also report SDK version in the User-Agent for convenience / visibility in logs. However
        // we don't want to set this in a browser environment as not all browsers support overriding
        // this header and it may result in un-suppressible errors in the browser console.
        // e.g: https://github.com/axios/axios/issues/1231
        if (!isBrowser()) {
            akahuHeaders['User-Agent'] = X_AKAHU_SDK;
        }
        // Filter user-provided config to ensure we only include supported options.
        const filteredAxiosOptions = pick(axiosOptions, ...allowedAxiosOptions);
        this.axios = axios__default['default'].create({
            ...filteredAxiosOptions,
            baseURL: buildUrl({ protocol, host, port, path: apiVersion }),
            headers: { ...filteredAxiosOptions.headers, ...akahuHeaders },
        });
        this.axios.interceptors.response.use(undefined, axiosRetryOnNetworkError);
        // Initialise client resources
        this.auth = new AuthResource(this);
        this.identities = new IdentitiesResource(this);
        this.users = new UsersResource(this);
        this.connections = new ConnectionsResource(this);
        this.accounts = new AccountsResource(this);
        this.payments = new PaymentsResource(this);
        this.transfers = new TransfersResource(this);
        this.transactions = new TransactionsResource(this);
        this.webhooks = new WebhooksResource(this);
    }
    _authorizeRequest(config, auth) {
        if (typeof auth !== 'undefined') {
            // Basic HTTP auth is use for "app" endpoints
            if ('basic' in auth && auth.basic) {
                const { appToken, appSecret } = this.authConfig;
                if (typeof appSecret === 'undefined') {
                    throw new Error('This resource requires authentication using your Akahu app secret. ' +
                        'Include this using the `appSecret` option when initializing the AkahuClient.');
                }
                return { ...config, auth: { username: appToken, password: appSecret } };
            }
            // Token auth is used for user-specific endpoints
            if ('token' in auth) {
                return {
                    ...config,
                    headers: {
                        ...config.headers,
                        Authorization: `Bearer ${auth.token}`,
                    }
                };
            }
        }
        return config;
    }
    _makeIdempotent(config) {
        var _a;
        if (((_a = config.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === 'POST') {
            return { ...config, headers: { ...config.headers,
                    'Idempotency-Key': uuid.v4() } };
        }
        return config;
    }
    _sanitizeQuery(query) {
        // Sanity check for attempts to paginate with a `null` cursor. This might
        // happen if the user blindly passes in the "next" cursor from a paginated
        // response without checking its value. `query.cursor` must either be
        // `undefined` or a string value.
        if (query.cursor === null) {
            throw new Error("Pagination cursor cannot be null. A null next cursor in an API " +
                "response indicates that the final page has been reached.");
        }
        return query;
    }
    /**
     * Generic API wrapper, exposed for use by client resources.
     * @internal
     */
    async _apiCall({ path, method = 'GET', query, data, auth }) {
        var _a, _b, _c;
        let params = query;
        if (typeof params !== 'undefined') {
            params = this._sanitizeQuery(params);
        }
        // Build up the request config object for axios
        let requestConfig = { url: path, method, params, data };
        requestConfig = this._authorizeRequest(requestConfig, auth);
        requestConfig = this._makeIdempotent(requestConfig);
        let response;
        try {
            response = await this.axios.request(requestConfig);
        }
        catch (e) {
            // Wrap error responses from the API
            if (typeof e.response !== 'undefined') {
                throw new AkahuErrorResponse(e.response);
            }
            // All other errors are re-raised.
            throw e;
        }
        // Unpack response:
        // - success will always be present
        // - cursor will be present in the case of paginated responses
        // - response value will generally be nested under `item`, `items`, or `item_id`
        const { success, cursor, ...payload } = response.data;
        // Check status flag from API. Generally we shouldn't hit this, as any response
        // with `success: false` should return a 4xx or 5xx status which would
        // cause an exception above.
        if (!success)
            throw new AkahuErrorResponse(response);
        // Results from paginated responses are always nested under `items`
        if (cursor) {
            return { cursor, items: payload.items };
        }
        // Unpacking of non-paginated response formats:
        // https://developers.akahu.nz/docs/response-formatting
        // Order is important here, as some endpoints return both `item` and
        // `item_id`, the latter of which is deprecated.
        return ((_c = (_b = (_a = payload.item // Single item response
        ) !== null && _a !== void 0 ? _a : payload.item_id // Item id response
        ) !== null && _b !== void 0 ? _b : payload.items // Item list response
        ) !== null && _c !== void 0 ? _c : (Object.keys(payload).length !== 0
            ? payload // OAuth response data is not nested to be spec-compliant
            : undefined) // No response payload: no return value
        );
    }
}

exports.AkahuClient = AkahuClient;
//# sourceMappingURL=index.js.map
